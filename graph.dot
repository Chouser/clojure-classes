digraph {
  rankdir=LR;
  dpi=55;
  nodesep=0.10;
  ranksep=1.2;
  mclimit=2500.0;
  node[ fontname=Helvetica shape=box ];

  subgraph cluster_legend {
    label="Legend"
    fontname="Helvetica Bold"
    fontsize=19
    bgcolor="#dddddd"
    "Clojure Interface" [ shape=octagon fillcolor="#ffffff" style=filled ];
    "Java Interface" [ shape=diamond fillcolor="#ffffff" style=filled ];
    "Clojure class" [ shape=oval fillcolor="#ffffff" style=filled ];
    badges [
      shape=record
      style=filled
      fillcolor="#ffffff"
      label="{{M|T|1|S|R|N|=}|{IMeta|Iterable|Counted|Streamable|Reversible|Named|Comparable}}"
    ]
  }
  "class clojure.lang.AFn" [ label="AFn\n[M]" color="#76d700" shape="oval"];
  "class clojure.lang.AFn" -> "class clojure.lang.Obj" [ color="#76d700" ];
  "class clojure.lang.AFn" -> "interface clojure.lang.IFn" [ color="#76d700" ];
  "class clojure.lang.AFn" -> "interface java.io.Serializable" [ color="#76d700" ];
  "class clojure.lang.AFunction" [ label="AFunction\n[M]" color="#d70000" shape="oval"];
  "class clojure.lang.AFunction" -> "class clojure.lang.AFn" [ color="#d70000" ];
  "class clojure.lang.AFunction" -> "interface java.util.Comparator" [ color="#d70000" ];
  "class clojure.lang.AFunction" -> "interface clojure.lang.Fn" [ color="#d70000" ];
  "class clojure.lang.AMapEntry" [ label="AMapEntry\n[MT1SR=]" color="#5a00d7" shape="oval"];
  "class clojure.lang.AMapEntry" -> "class clojure.lang.APersistentVector" [ color="#5a00d7" ];
  "class clojure.lang.AMapEntry" -> "interface clojure.lang.IMapEntry" [ color="#5a00d7" ];
  "class clojure.lang.APersistentMap" [ label="APersistentMap\n[MT1]" color="#b300d7" shape="oval"];
  "class clojure.lang.APersistentMap" -> "class clojure.lang.AFn" [ color="#b300d7" ];
  "class clojure.lang.APersistentMap" -> "interface clojure.lang.IPersistentMap" [ color="#b300d7" ];
  "class clojure.lang.APersistentMap" -> "interface java.util.Map" [ color="#b300d7" ];
  "class clojure.lang.APersistentSet" [ label="APersistentSet\n[MT1]" color="#5a00d7" shape="oval"];
  "class clojure.lang.APersistentSet" -> "class clojure.lang.AFn" [ color="#5a00d7" ];
  "class clojure.lang.APersistentSet" -> "interface clojure.lang.IPersistentSet" [ color="#5a00d7" ];
  "class clojure.lang.APersistentSet" -> "interface java.util.Collection" [ color="#5a00d7" ];
  "class clojure.lang.APersistentSet" -> "interface java.util.Set" [ color="#5a00d7" ];
  "class clojure.lang.APersistentVector" [ label="APersistentVector\n[MT1SR=]" color="#b300d7" shape="oval"];
  "class clojure.lang.APersistentVector" -> "class clojure.lang.AFn" [ color="#b300d7" ];
  "class clojure.lang.APersistentVector" -> "interface clojure.lang.IPersistentVector" [ color="#b300d7" ];
  "class clojure.lang.APersistentVector" -> "interface java.util.List" [ color="#b300d7" ];
  "class clojure.lang.APersistentVector" -> "interface java.util.RandomAccess" [ color="#b300d7" ];
  "class clojure.lang.ARef" [ label="ARef\n[M]" color="#00d0d7" shape="oval"];
  "class clojure.lang.ARef" -> "class clojure.lang.AReference" [ color="#00d0d7" ];
  "class clojure.lang.ARef" -> "interface clojure.lang.IRef" [ color="#00d0d7" ];
  "class clojure.lang.AReference" [ label="AReference\n[M]" color="#d70000" shape="oval"];
  "class clojure.lang.AReference" -> "interface clojure.lang.IReference" [ color="#d70000" ];
  "class clojure.lang.ASeq" [ label="ASeq\n[MTS]" color="#00d0d7" shape="oval"];
  "class clojure.lang.ASeq" -> "class clojure.lang.Obj" [ color="#00d0d7" ];
  "class clojure.lang.ASeq" -> "interface clojure.lang.ISeq" [ color="#00d0d7" ];
  "class clojure.lang.ASeq" -> "interface java.util.List" [ color="#00d0d7" ];
  "class clojure.lang.Agent" [ label="Agent\n[M]" color="#00d764" shape="oval"];
  "class clojure.lang.Agent" -> "class clojure.lang.ARef" [ color="#00d764" ];
  "class clojure.lang.ArraySeq" [ label="ArraySeq\n[MT1S]" color="#5a00d7" shape="oval"];
  "class clojure.lang.ArraySeq" -> "class clojure.lang.ASeq" [ color="#5a00d7" ];
  "class clojure.lang.ArraySeq" -> "interface clojure.lang.IndexedSeq" [ color="#5a00d7" ];
  "class clojure.lang.ArraySeq" -> "interface clojure.lang.IReduce" [ color="#5a00d7" ];
  "class clojure.lang.ArrayStream" [ label="ArrayStream" color="#d70000" shape="oval"];
  "class clojure.lang.ArrayStream" -> "interface clojure.lang.IStream" [ color="#d70000" ];
  "interface clojure.lang.Associative" [ label="Associative\nassociative?" color="#76d700" shape="octagon"];
  "interface clojure.lang.Associative" -> "interface clojure.lang.IPersistentCollection" [ color="#76d700" ];
  "class clojure.lang.Atom" [ label="Atom\n[M]" color="#b300d7" shape="oval"];
  "class clojure.lang.Atom" -> "class clojure.lang.ARef" [ color="#b300d7" ];
  "interface java.util.concurrent.Callable" [ label="Callable" color="#00d764" shape="diamond"];
  "interface java.util.Collection" [ label="Collection\n[T]" color="#00d764" shape="diamond"];
  "interface java.util.Comparator" [ label="Comparator" color="#00d0d7" shape="diamond"];
  "interface java.util.concurrent.ConcurrentMap" [ label="ConcurrentMap" color="#0061d7" shape="diamond"];
  "interface java.util.concurrent.ConcurrentMap" -> "interface java.util.Map" [ color="#0061d7" ];
  "class clojure.lang.Cons" [ label="Cons\n[MTS]" color="#76d700" shape="oval"];
  "class clojure.lang.Cons" -> "class clojure.lang.ASeq" [ color="#76d700" ];
  "class clojure.lang.Delay" [ label="Delay\ndelay?" color="#5a00d7" shape="oval"];
  "class clojure.lang.Delay" -> "interface clojure.lang.IDeref" [ color="#5a00d7" ];
  "interface java.util.Map$Entry" [ label="Entry" color="#d7009e" shape="diamond"];
  "interface java.util.Enumeration" [ label="Enumeration" color="#5a00d7" shape="diamond"];
  "class clojure.lang.EnumerationSeq" [ label="EnumerationSeq\n[MTS]" color="#00d0d7" shape="oval"];
  "class clojure.lang.EnumerationSeq" -> "class clojure.lang.ASeq" [ color="#00d0d7" ];
  "interface clojure.lang.Fn" [ label="Fn\nfn?" color="#0061d7" shape="octagon"];
  "interface clojure.lang.IDeref" [ label="IDeref" color="#00d764" shape="octagon"];
  "interface clojure.lang.IFn" [ label="IFn\nifn?" color="#0061d7" shape="octagon"];
  "interface clojure.lang.IFn" -> "interface java.util.concurrent.Callable" [ color="#0061d7" ];
  "interface clojure.lang.IFn" -> "interface java.lang.Runnable" [ color="#0061d7" ];
  "interface clojure.lang.IMapEntry" [ label="IMapEntry" color="#00d0d7" shape="octagon"];
  "interface clojure.lang.IMapEntry" -> "interface java.util.Map$Entry" [ color="#00d0d7" ];
  "interface clojure.lang.IObj" [ label="IObj\n[M]" color="#0061d7" shape="octagon"];
  "interface clojure.lang.IPersistentCollection" [ label="IPersistentCollection\ncoll?" color="#d7009e" shape="octagon"];
  "interface clojure.lang.IPersistentCollection" -> "interface clojure.lang.Seqable" [ color="#d7009e" ];
  "interface clojure.lang.IPersistentList" [ label="IPersistentList\nlist?" color="#5a00d7" shape="octagon"];
  "interface clojure.lang.IPersistentList" -> "interface clojure.lang.Sequential" [ color="#5a00d7" ];
  "interface clojure.lang.IPersistentList" -> "interface clojure.lang.IPersistentStack" [ color="#5a00d7" ];
  "interface clojure.lang.IPersistentMap" [ label="IPersistentMap\nmap?\n[T1]" color="#d70000" shape="octagon"];
  "interface clojure.lang.IPersistentMap" -> "interface clojure.lang.Associative" [ color="#d70000" ];
  "interface clojure.lang.IPersistentSet" [ label="IPersistentSet\nset?\n[1]" color="#d7009e" shape="octagon"];
  "interface clojure.lang.IPersistentSet" -> "interface clojure.lang.IPersistentCollection" [ color="#d7009e" ];
  "interface clojure.lang.IPersistentStack" [ label="IPersistentStack" color="#00d764" shape="octagon"];
  "interface clojure.lang.IPersistentStack" -> "interface clojure.lang.IPersistentCollection" [ color="#00d764" ];
  "interface clojure.lang.IPersistentVector" [ label="IPersistentVector\nvector?\n[1R]" color="#d7009e" shape="octagon"];
  "interface clojure.lang.IPersistentVector" -> "interface clojure.lang.Associative" [ color="#d7009e" ];
  "interface clojure.lang.IPersistentVector" -> "interface clojure.lang.Sequential" [ color="#d7009e" ];
  "interface clojure.lang.IPersistentVector" -> "interface clojure.lang.IPersistentStack" [ color="#d7009e" ];
  "interface clojure.lang.IReduce" [ label="IReduce" color="#d7009e" shape="octagon"];
  "interface clojure.lang.IRef" [ label="IRef" color="#b300d7" shape="octagon"];
  "interface clojure.lang.IRef" -> "interface clojure.lang.IDeref" [ color="#b300d7" ];
  "interface clojure.lang.IReference" [ label="IReference\n[M]" color="#d78100" shape="octagon"];
  "interface clojure.lang.ISeq" [ label="ISeq\nseq?" color="#b300d7" shape="octagon"];
  "interface clojure.lang.ISeq" -> "interface clojure.lang.IPersistentCollection" [ color="#b300d7" ];
  "interface clojure.lang.ISeq" -> "interface clojure.lang.Sequential" [ color="#b300d7" ];
  "interface clojure.lang.IStream" [ label="IStream" color="#00d0d7" shape="octagon"];
  "interface clojure.lang.IndexedSeq" [ label="IndexedSeq\n[1]" color="#0061d7" shape="octagon"];
  "interface clojure.lang.IndexedSeq" -> "interface clojure.lang.ISeq" [ color="#0061d7" ];
  "interface java.lang.reflect.InvocationHandler" [ label="InvocationHandler" color="#b300d7" shape="diamond"];
  "interface java.util.Iterator" [ label="Iterator" color="#5a00d7" shape="diamond"];
  "class clojure.lang.IteratorSeq" [ label="IteratorSeq\n[MTS]" color="#0061d7" shape="oval"];
  "class clojure.lang.IteratorSeq" -> "class clojure.lang.ASeq" [ color="#0061d7" ];
  "class clojure.lang.IteratorStream" [ label="IteratorStream" color="#00d0d7" shape="oval"];
  "class clojure.lang.IteratorStream" -> "interface clojure.lang.IStream" [ color="#00d0d7" ];
  "class clojure.lang.Keyword" [ label="Keyword\nkeyword?\n[N=]" color="#76d700" shape="oval"];
  "class clojure.lang.Keyword" -> "interface clojure.lang.IFn" [ color="#76d700" ];
  "class clojure.lang.LazilyPersistentVector" [ label="LazilyPersistentVector\n[MT1SR=]" color="#d70000" shape="oval"];
  "class clojure.lang.LazilyPersistentVector" -> "class clojure.lang.APersistentVector" [ color="#d70000" ];
  "class clojure.lang.LazySeq" [ label="LazySeq\n[MT]" color="#d78100" shape="oval"];
  "class clojure.lang.LazySeq" -> "class clojure.lang.AFn" [ color="#d78100" ];
  "class clojure.lang.LazySeq" -> "interface clojure.lang.ISeq" [ color="#d78100" ];
  "class clojure.lang.LazySeq" -> "interface java.util.List" [ color="#d78100" ];
  "interface java.util.List" [ label="List\n[T]" color="#00d764" shape="diamond"];
  "interface java.util.List" -> "interface java.util.Collection" [ color="#00d764" ];
  "interface java.util.Map" [ label="Map" color="#00d764" shape="diamond"];
  "class clojure.lang.MapEntry" [ label="MapEntry\n[MT1SR=]" color="#0061d7" shape="oval"];
  "class clojure.lang.MapEntry" -> "class clojure.lang.AMapEntry" [ color="#0061d7" ];
  "class clojure.lang.MultiFn" [ label="MultiFn\n[M]" color="#76d700" shape="oval"];
  "class clojure.lang.MultiFn" -> "class clojure.lang.AFn" [ color="#76d700" ];
  "class clojure.lang.Namespace" [ label="Namespace\n[M]" color="#76d700" shape="oval"];
  "class clojure.lang.Namespace" -> "class clojure.lang.AReference" [ color="#76d700" ];
  "class clojure.lang.Obj" [ label="Obj\n[M]" color="#00d764" shape="oval"];
  "class clojure.lang.Obj" -> "interface clojure.lang.IObj" [ color="#00d764" ];
  "class clojure.lang.PersistentArrayMap" [ label="PersistentArrayMap\n[MT1]" color="#5a00d7" shape="oval"];
  "class clojure.lang.PersistentArrayMap" -> "class clojure.lang.APersistentMap" [ color="#5a00d7" ];
  "class clojure.lang.PersistentHashMap" [ label="PersistentHashMap\n[MT1]" color="#0061d7" shape="oval"];
  "class clojure.lang.PersistentHashMap" -> "class clojure.lang.APersistentMap" [ color="#0061d7" ];
  "class clojure.lang.PersistentHashSet" [ label="PersistentHashSet\n[MT1]" color="#5a00d7" shape="oval"];
  "class clojure.lang.PersistentHashSet" -> "class clojure.lang.APersistentSet" [ color="#5a00d7" ];
  "class clojure.lang.PersistentList" [ label="PersistentList\n[MT1S]" color="#76d700" shape="oval"];
  "class clojure.lang.PersistentList" -> "class clojure.lang.ASeq" [ color="#76d700" ];
  "class clojure.lang.PersistentList" -> "interface clojure.lang.IPersistentList" [ color="#76d700" ];
  "class clojure.lang.PersistentList" -> "interface clojure.lang.IReduce" [ color="#76d700" ];
  "class clojure.lang.PersistentList" -> "interface java.util.List" [ color="#76d700" ];
  "class clojure.lang.PersistentQueue" [ label="PersistentQueue\n[MT]" color="#0061d7" shape="oval"];
  "class clojure.lang.PersistentQueue" -> "class clojure.lang.Obj" [ color="#0061d7" ];
  "class clojure.lang.PersistentQueue" -> "interface clojure.lang.IPersistentList" [ color="#0061d7" ];
  "class clojure.lang.PersistentQueue" -> "interface java.util.Collection" [ color="#0061d7" ];
  "class clojure.lang.PersistentStructMap" [ label="PersistentStructMap\n[MT1]" color="#00d0d7" shape="oval"];
  "class clojure.lang.PersistentStructMap" -> "class clojure.lang.APersistentMap" [ color="#00d0d7" ];
  "class clojure.lang.PersistentTreeMap" [ label="PersistentTreeMap\n[MT1R]" color="#d78100" shape="oval"];
  "class clojure.lang.PersistentTreeMap" -> "class clojure.lang.APersistentMap" [ color="#d78100" ];
  "class clojure.lang.PersistentTreeMap" -> "interface clojure.lang.Sorted" [ color="#d78100" ];
  "class clojure.lang.PersistentTreeSet" [ label="PersistentTreeSet\n[MT1R]" color="#d70000" shape="oval"];
  "class clojure.lang.PersistentTreeSet" -> "class clojure.lang.APersistentSet" [ color="#d70000" ];
  "class clojure.lang.PersistentTreeSet" -> "interface clojure.lang.Sorted" [ color="#d70000" ];
  "class clojure.lang.PersistentVector" [ label="PersistentVector\n[MT1SR=]" color="#d78100" shape="oval"];
  "class clojure.lang.PersistentVector" -> "class clojure.lang.APersistentVector" [ color="#d78100" ];
  "class clojure.lang.ProxyHandler" [ label="ProxyHandler" color="#0061d7" shape="oval"];
  "class clojure.lang.ProxyHandler" -> "interface java.lang.reflect.InvocationHandler" [ color="#0061d7" ];
  "interface java.util.RandomAccess" [ label="RandomAccess" color="#d7009e" shape="diamond"];
  "class clojure.lang.Range" [ label="Range\n[MT1S]" color="#00d0d7" shape="oval"];
  "class clojure.lang.Range" -> "class clojure.lang.ASeq" [ color="#00d0d7" ];
  "class clojure.lang.Range" -> "interface clojure.lang.IReduce" [ color="#00d0d7" ];
  "class clojure.lang.Ratio" [ label="Ratio\nratio?\n[=]" color="#d78100" shape="oval"];
  "class clojure.lang.Ref" [ label="Ref\n[M=]" color="#d78100" shape="oval"];
  "class clojure.lang.Ref" -> "class clojure.lang.ARef" [ color="#d78100" ];
  "class clojure.lang.Ref" -> "interface clojure.lang.IFn" [ color="#d78100" ];
  "class clojure.lang.Ref" -> "interface clojure.lang.IRef" [ color="#d78100" ];
  "class clojure.lang.RestFn" [ label="RestFn\n[M]" color="#0061d7" shape="oval"];
  "class clojure.lang.RestFn" -> "class clojure.lang.AFunction" [ color="#0061d7" ];
  "interface java.lang.Runnable" [ label="Runnable" color="#00d0d7" shape="diamond"];
  "class clojure.lang.SeqEnumeration" [ label="SeqEnumeration" color="#0061d7" shape="oval"];
  "class clojure.lang.SeqEnumeration" -> "interface java.util.Enumeration" [ color="#0061d7" ];
  "class clojure.lang.SeqIterator" [ label="SeqIterator" color="#76d700" shape="oval"];
  "class clojure.lang.SeqIterator" -> "interface java.util.Iterator" [ color="#76d700" ];
  "interface clojure.lang.Seqable" [ label="Seqable" color="#d78100" shape="octagon"];
  "interface clojure.lang.Sequential" [ label="Sequential\nsequential?" color="#d78100" shape="octagon"];
  "interface java.io.Serializable" [ label="Serializable" color="#5a00d7" shape="diamond"];
  "interface java.util.Set" [ label="Set\n[T]" color="#00d0d7" shape="diamond"];
  "interface java.util.Set" -> "interface java.util.Collection" [ color="#00d0d7" ];
  "interface clojure.lang.Settable" [ label="Settable" color="#0061d7" shape="octagon"];
  "interface clojure.lang.Sorted" [ label="Sorted\nsorted?" color="#5a00d7" shape="octagon"];
  "class clojure.lang.StreamSeq" [ label="StreamSeq\n[MTS]" color="#5a00d7" shape="oval"];
  "class clojure.lang.StreamSeq" -> "class clojure.lang.ASeq" [ color="#5a00d7" ];
  "class clojure.lang.StringSeq" [ label="StringSeq\n[MT1S]" color="#d7009e" shape="oval"];
  "class clojure.lang.StringSeq" -> "class clojure.lang.ASeq" [ color="#d7009e" ];
  "class clojure.lang.StringSeq" -> "interface clojure.lang.IndexedSeq" [ color="#d7009e" ];
  "class clojure.lang.Symbol" [ label="Symbol\nsymbol?\n[MN=]" color="#0061d7" shape="oval"];
  "class clojure.lang.Symbol" -> "class clojure.lang.AFn" [ color="#0061d7" ];
  "class clojure.lang.Symbol" -> "interface java.io.Serializable" [ color="#0061d7" ];
  "class clojure.lang.TransactionalHashMap" [ label="TransactionalHashMap" color="#d7009e" shape="oval"];
  "class clojure.lang.TransactionalHashMap" -> "interface java.util.concurrent.ConcurrentMap" [ color="#d7009e" ];
  "class clojure.lang.Var" [ label="Var\nvar?\n[M]" color="#00d0d7" shape="oval"];
  "class clojure.lang.Var" -> "class clojure.lang.ARef" [ color="#00d0d7" ];
  "class clojure.lang.Var" -> "interface clojure.lang.IFn" [ color="#00d0d7" ];
  "class clojure.lang.Var" -> "interface clojure.lang.IRef" [ color="#00d0d7" ];
  "class clojure.lang.Var" -> "interface clojure.lang.Settable" [ color="#00d0d7" ];
}
